<!DOCTYPE html>
<html lang="en" >

<head>
  <meta charset="UTF-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Interactive map of the night sky">
  <meta name="keywords" content="stars, sky, astrology, constellations">

  <meta name="theme-color" content="#16191f">
  <meta name="mobile-web-app-capable" content="yes">
  <title>skyAtlas</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
  <link rel="stylesheet" href="css/style.css">
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" type="image/png" href="/textures/icons/icon96.png" />
  <link rel="apple-touch-icon" href="/textures/icons/icon96.png" />
</head>

<body>
  <noscript>You need to enable JavaScript to run this app.</noscript>
<!--BLACK MAGICS-->
  <!-- STAR FIELD SHADER -->
  <script type="x-shader/x-vertex" id="vertexshader">
    uniform float scale;
    attribute float size;
    attribute float alpha;
    varying vec3 vColor;
    varying float vAlpha;
    
    void main() {
        vColor = color;
	      vAlpha = alpha;
        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
        gl_PointSize = size*(120.0) * ((scale / -mvPosition.z));
        gl_Position = projectionMatrix * mvPosition;
    }
  </script>

  <script type="x-shader/x-fragment" id="fragmentshader">
    uniform sampler2D texture;
    uniform float time;
    varying vec3 vColor;
    varying float vAlpha;

    void main() {
        gl_FragColor = vec4( vColor * (1.0 - (sin(time*vAlpha))*0.3) , 1 );
        gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
    }
  </script>
  <!--STAR CLOSEUP SHADERS-->
  <script type="x-shader/x-vertex" id="haloShaderVert">
    varying vec2 vUv;

    void main()
    {
      vUv = uv;
      vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
      gl_Position = projectionMatrix * mvPosition;
    }
  </script>

  <script type="x-shader/x-fragment" id="haloShaderFrag">
    #define PI 3.14159265359
    #define TWO_PI 6.28318530718
    #define SQ3 1.73205080757
    #define SIZE 400.0
    #define I_R 100.0
    #define F_R 400.0
    #define SPEED 0.4

    precision highp float;

    precision highp int;
    uniform float time;
    uniform vec2 resolution;
    uniform vec3 color;
    varying vec2 vUv;
    float random(in vec2 _st)
    {
      return fract(sin(dot(_st.xy, vec2(12.9898, 78.233))) * 43758.54531237);
    }
    float noise(in vec2 _st)
    {
      vec2 i = floor(_st);
      vec2 f = fract(_st);
      float a = random(i);
      float b = random(i + vec2(1.0, 0.0));
      float c = random(i + vec2(0.0, 1.0));
      float d = random(i + vec2(1.0, 1.0));
      vec2 u = f * f * (3. - 2.0 * f);
      return mix(a, b, u.x) + (c - a) * u.y * (1. - u.x) + (d - b) * u.x * u.y;
    }
    float noise(float _st)
    {
      return fract(abs(sin(_st)));
    }
    vec4 flare(float alpha, vec2 main, float seed, float dir)
    {

      float amnt = 0.6 + sin(seed) * 8.0;
      float ang = atan(main.y, main.x);
      float t = time * SPEED * dir;
      float n = noise(vec2((seed + ang * amnt + t * 0.1) + cos(alpha * 13.8 + noise(t + ang + seed) * 3.0) * 0.2 + seed / 20.0, seed + t + ang));
      n *= pow(noise(vec2(seed * 194.0 + ang * amnt + t + cos(alpha * 2.0 * n + t * 1.1 + ang) * 2.8, seed + t + ang) + alpha), 2.0);
      n *= pow(noise(vec2(seed * 134.0 + ang * amnt + t + cos(alpha * 2.2 * n + t * 1.1 + ang) * 1.1, seed + t + ang) + alpha), 3.0);
      n *= pow(noise(vec2(seed * 123.0 + ang * amnt + t + cos(alpha * 2.3 * n + t * 1.1 + ang) * 0.8, seed + t + ang) + alpha), 4.0);
      n *= pow(alpha, 2.6);
      n *= (ang + PI) / 2.0 * (TWO_PI - ang - PI);
      n += sqrt(alpha * alpha) * 0.26;
      return vec4(pow(n * 2.1, 2.0), n, n, n);
    }
    void main()
    {
      float size = 600.0;
      vec2 uv = (vUv.xy * size - resolution.xy * size * 0.5) / resolution.y;
      vec4 c = vec4(0.0);
      float len = length(uv);
      float alpha = pow(clamp(F_R - len + I_R - 40.0, 0.0, F_R) / F_R, 6.0);
      c += flare(alpha, uv, 74.621, 1.0);
      c += flare(alpha, uv, 35.1412, 1.0);
      c += flare(alpha, uv, 21.5637, 1.0);
      c += flare(alpha, uv, 1.2637, 1.0);
      c.xyz = clamp(c.xyz, 0.0, 1.0);
      if (alpha >= 0.99)
      {
          c.a = alpha; //middle section trasnsparency
      }
       gl_FragColor = vec4(color, c.a);
    }
  </script>

  <script type="x-shader/x-vertex" id="bodyShaderVert">
    // Set the precision for data types used in this shader
    precision highp float;

    // Default attributes provided by THREE.js. Attributes are only available in the
    // vertex shader. You can pass them to the fragment shader using varyings
    //attribute vec3 position;
    //attribute vec3 normal;
    //attribute vec2 uv;
    attribute vec2 uv2;

    // Examples of variables passed from vertex to fragment shader
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec2 vUv;
    varying vec2 vUv2;
    varying vec3 fNormal;
    varying vec3 fPosition;

    void main() {

        // To pass variables to the fragment shader, you assign them here in the
        // main function. Traditionally you name the varying with vAttributeName
        vNormal = normal;
        vUv = uv;
        vUv2 = uv2;
        vPosition = position;
        //glow
        fNormal = normalize(normalMatrix*normal);
        vec4 pos = modelViewMatrix * vec4(position, 1.0);
        fPosition = pos.xyz;

        // This sets the position of the vertex in 3d space. The correct math is
        // provided below to take into account camera and object data.
        //gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        gl_Position = projectionMatrix * pos;
    }
  </script>

  <script type="x-shader/x-fragment" id="bodyShaderFrag">
    precision highp float;

    uniform float time;
    uniform float speed;
    uniform vec3 veinColor;
    //uniform float veinBrightness;
    uniform vec3 color;
    uniform vec2 resolution;
    varying vec2 vUv;
    varying vec3 fPosition;
    varying vec3 fNormal;

    uniform sampler2D iChannel0;

    #define PI 3.14159265

    //vec3 saturate( vec3 i ) {return clamp( i, 0.0, 1.0 );}
    //float saturate( float i ) {return clamp( i, 0.0, 1.0 );}

    vec4 texture2DNearest( sampler2D _tex, vec2 _uv, vec2 _reso ){
      return texture2D( _tex, ( floor( _uv * _reso ) + 0.5 ) / _reso );
    }

    float expCurve( float _in, float _lv ){
      return sign( 0.5 - _in ) * ( exp( -abs( _in - 0.5 ) * _lv ) - 1.0 ) * 0.5 + 0.5;
    }

    vec4 noise( vec2 _uv, vec2 _mul, vec2 _off, float _iter, float _lacu ){
      vec4 sum = vec4( 0.0 );

      for( float i=0.0; i<99.0; i+=1.0 ){
          vec2 uv0 = ( ( _uv ) * _mul + _off ) * 0.01 * exp( i * _lacu ) + time * speed * i * 0.01;
          vec2 uv1 = ( ( _uv + vec2( 1.0, 0.0 ) ) * _mul + _off ) * 0.01 * exp( i * _lacu ) + time * speed * i * 0.01;
          vec4 tex0 = texture2D( iChannel0, uv0 );
          vec4 tex1 = texture2D( iChannel0, uv1 );
          vec4 tex = mix( tex1, tex0, expCurve( _uv.x, 10.0 ) );
          sum += tex / pow( 2.0, i + 1.0 );
          if( _iter < i ){ break; }
      }

      return sum;
    }

    vec4 Body_main(){
          vec4 Body_gl_FragColor = vec4(0.0);
          vec2 uv = mod( vUv.xy / resolution, 1.0 );
          uv = mod( uv + vec2( 0.5, 0.0 ), 1.0 );

          // 1
          vec3 col1 = vec3( 0.0 );

          float line = 0.0;
          for( float i=0.0; i<8.5; i+=1.0 ){
              vec2 mul = vec2( exp( i * 0.3 ) );
              vec2 off = vec2( i * 423.1 );

              float lineL = 1.0 - abs( noise( uv, mul * vec2( 2.0, 1.5 ), off, 2.0, 0.4 ).x - 0.5 ) * 2.0;
              float lineS = 1.0 - abs( noise( uv, mul * vec2( 14.0 ), off + 10.0, 6.0, 0.7 ).x - 0.5 ) * 2.0;

              float lineT = expCurve( pow( lineL, 200.0 ), 7.0 ) * 1.0;
              lineT += pow( lineL, 12.0 ) * expCurve( pow( lineS, 40.0 ), 10.0 ) * 1.0;
              //lineT = saturate( lineT );
              lineT *= expCurve( noise( uv, mul * 7.0, off + 20.0, 6.0, 1.0 ).x * 0.88, 20.0 );

              line += lineT * exp( -i * 0.01 );
          }

          //line = saturate( line );

          col1 = vec3( 0.9 ) * color;

          col1 = mix(
              col1,
              color * 0.8,
              expCurve( noise( uv, vec2( 4.0 ), vec2( 40.0 ), 5.0, 0.7 ).x * 0.7, 14.0 )
          );

          col1 = mix(
              col1,
              color * 0.8,
              expCurve( noise( uv, vec2( 4.0 ), vec2( 50.0 ), 5.0, 0.7 ).x * 0.7, 5.0 ) * 0.7
          );

          col1 = mix(
              col1,
              color * 2.0, //4.0 = veinBrightness
              line
          );

          vec3 col = col1;
          Body_gl_FragColor = vec4(col, 1.0);
          return Body_gl_FragColor *= 1.0;

      }
    vec4 Glow_main(){
      vec4 Glow_gl_FragColor = vec4(1.0);
      vec3 normal = normalize(fNormal);
      vec3 eye = normalize(-fPosition.xyz);
      float rim = smoothstep(0.2, 1.2, 1.0 - dot(normal, eye));
      Glow_gl_FragColor = vec4( clamp(rim, 0.0, 1.0) * 1.0 * color, 1.0 );
      return Glow_gl_FragColor *= 1.0;
    }

    void main(){
          gl_FragColor = (Body_main() + Glow_main());
    }
  </script>
<!--BLACK MAGICS END-->
  <div id="Stats-Output">
  </div>
  <!-- Div which will hold the Output -->
  <div id="WebGL-Output">
    <div style="display:none">
			<span id="marker_template" class="marker"><span class="name">
			</span></span>
		</div>
  </div>

  <!--CONTROLS-->
  <button id="return" class="hidden" onclick="goBack()">
    <img src="textures/icons/return-icon.png" class="icon" />
  </button>
  <button id="scroll-down" class="hidden" onclick="scrolling('down')">
    <img src="textures/icons/scroll-icon.png" class="icon" />
  </button>
  <div id="scroll-container" class="hidden" onclick="scrolling('up')">
    <button id="scroll-up">
      <img src="textures/icons/scroll-icon.png" class="icon" />
    </button>
  </div>

  <div id="object"></div>
  <div id="coordinates"></div>
  <div id="loading-screen">
    <div class="loader"></div>
  </div>
  <!--MODALS-->
  <div id="name-container"></div>
  <div id="description-container"><!--Object description goes here--></div>

  <script src='serviceWorker.js'></script>

  <script src="lib/dat.gui.js"></script>
  <script src='lib/d3.min.js'></script>
  <script src='lib/three.min.js'></script>
  <script src='lib/TrackballControls.js'></script>
  <script src='lib/DeviceOrientationControls.js'></script>

  <script src='js/galaxy.js'></script>
  <script src='js/helperfunctions.js'></script>  
  <script src='js/constellation.js'></script>
  <script src='js/skybox.js'></script>
  <script src='js/object.js'></script>
  <script src='js/highlight.js'></script>
  <script src='js/parseData.js'></script>
  <script src='js/return.js'></script>
  <script src='js/geolocation.js'></script>
  <script src='js/wikiLookup.js'></script>
  
  <script src='js/index.js'></script>

</body>

</html>
